import { ModuleKind, ScriptTarget, transpileModule } from "typescript";
import { readFileSync, writeFileSync, existsSync, readdirSync } from "fs";
import { fileURLToPath } from "url";
import { dirname, resolve } from "path";
import chalk from "chalk";
const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
const AG_TITLE = `/**
 * æ­¤æ–‡ä»¶ç”±æ’ä»¶è‡ªåŠ¨ç”Ÿæˆï¼Œè¯·å‹¿æ‰‹åŠ¨ä¿®æ”¹æˆ–åˆ é™¤
 * Generated by /vitePlugins/genDTS.ts
 */
`;

let enumDTSTimeout: NodeJS.Timeout | null = null;
export const genEnumDTS = () => {
  enumDTSTimeout && clearTimeout(enumDTSTimeout);
  enumDTSTimeout = setTimeout(() => {
    console.time(chalk.green("generate use time"));
    console.log(
      new Date().toLocaleTimeString().slice(0, 8),
      chalk.blue("[hot-update-plugin]"),
      chalk.green("ğŸš€", "åŒæ­¥enums.tsçš„ENUM_CODEåˆ°utils")
    );
    const output = resolve(__dirname, "../src/utils/enums.ag.ts");
    const enumsTsPath = resolve(__dirname, "../src/invokes/enums.ts");
    const enumsTsContent = readFileSync(enumsTsPath, "utf-8");
    const enumsJs = transpileModule(enumsTsContent, {
      compilerOptions: {
        module: ModuleKind.ESNext,
        target: ScriptTarget.ESNext,
      },
    }).outputText.replace(/export /g, "");
    try {
      const genEnumCode =
        "export " + new Function("", enumsJs + ";return ENUM_CODE")().trim();
      if (existsSync(output)) {
        const outputContent = readFileSync(output, "utf-8").trim();
        if (genEnumCode === outputContent) {
          console.log(
            "âœ¨",
            "The",
            chalk.green("enums.ag.ts"),
            "file is not changed"
          );
          console.timeEnd(chalk.green("generate use time"));
          return;
        }
      }
      writeFileSync(output, genEnumCode);
      console.log(
        "âœ¨",
        "The",
        chalk.green("enums.ag.ts"),
        "file is generated in the:",
        chalk.blue(output)
      );
      console.timeEnd(chalk.green("generate use time"));
    } catch (e) {
      console.error("âŒ", e);
      console.timeEnd(chalk.green("generate use time"));
    }
  }, 500);
};

const genCoreDTS = (declareContent: string) => {
  const useCorePath = resolve(__dirname, "../src/hooks/useCore.ts");
  const coreString = readFileSync(useCorePath, "utf-8");
  const coreMatch = coreString.match(/CORE_NAMESPACES = ["'](.*?)['"]/);
  if (!(coreMatch && coreMatch[1])) {
    throw new Error("useCore.tsæ–‡ä»¶ä¸­æ²¡æœ‰æ‰¾åˆ°CORE_NAMESPACESå˜é‡");
  }
  const CORE_NAMESPACES = coreMatch[1];
  const declareGlobalTemp = `/* eslint-disable */
/* prettier-ignore */
// @ts-nocheck
// noinspection JSUnusedGlobalSymbols
// Generated by /script/genBuiltInApiType.js
export {};
declare global {
  interface Window {
    ${CORE_NAMESPACES}: {${declareContent}
    } & ReturnType<typeof import("../../hooks/useScriptApi")["useBuiltInApi"]>;
  }
}
`;
  const declareGlobalPath = resolve(
    __dirname,
    "../src/types/auto_gen_types/core.d.ts"
  );
  let needUpdate = true;
  if (existsSync(declareGlobalPath)) {
    const outputContent = readFileSync(declareGlobalPath, "utf-8").trim();
    if (declareGlobalTemp.trim() === outputContent) {
      console.log("âœ¨", "The", chalk.green("core.d.ts"), "file is not changed");
      needUpdate = false;
    }
  }
  if (needUpdate) {
    writeFileSync(declareGlobalPath, declareGlobalTemp);
    console.log(
      "âœ¨",
      "The",
      chalk.green("core.d.ts"),
      "file is generated in the:",
      chalk.blue(declareGlobalPath)
    );
  }
};

const genBIDTS = (content: string, invokesPath: string) => {
  const outputPath = resolve(
    invokesPath,
    "../types/auto_gen_types/builtInApi.d.ts"
  );
  const builtInApiType = "declare type BuiltInApiType = {\n" + content + "};\n";
  let needUpdate = true;
  if (existsSync(outputPath)) {
    const outputContent = readFileSync(outputPath, "utf-8").trim();
    if (builtInApiType.trim() === outputContent) {
      console.log(
        "âœ¨",
        "The",
        chalk.green("builtInApi.d.ts"),
        "file is not changed"
      );
      needUpdate = false;
    }
  }
  if (needUpdate) {
    writeFileSync(outputPath, builtInApiType);
    console.log(
      "âœ¨",
      "The",
      chalk.green("builtInApi.d.ts"),
      "file is generated in the:",
      chalk.blue(outputPath)
    );
  }
};

let genBITSTimer: NodeJS.Timeout | null = null;
export const genBuiltInApiDTS = (genType: "declare" | "api" = "api") => {
  genBITSTimer && clearTimeout(genBITSTimer);
  genBITSTimer = setTimeout(() => {
    const invokesPath = resolve(__dirname, "../src/invokes");
    let content = "";
    let declareContent = "";
    try {
      console.log(
        new Date().toLocaleTimeString().slice(0, 8),
        chalk.blue("[hot-update-plugin]"),
        chalk.green("ğŸš€", "å¼€å§‹ç”Ÿæˆå†…ç½®APIçš„ç±»å‹æ–‡ä»¶")
      );
      console.time(chalk.green("generate use time"));
      const dirs = readdirSync(invokesPath, { withFileTypes: true })
        .filter((dirent) => dirent.isDirectory())
        .map((dirent) => dirent.name);
      dirs.forEach((dir) => {
        const dirPath = resolve(invokesPath, dir);
        const files = readdirSync(dirPath);
        if (files.includes("index.ts")) {
          const indexFilePath = resolve(dirPath, "index.ts");
          const fileContent = readFileSync(indexFilePath, "utf-8");
          if (/\sdisabled:\s?(true|([1-9][0-9]*)),?/.test(fileContent)) {
            console.warn(
              "âš ï¸ ",
              chalk.blue(indexFilePath),
              chalk.yellow(":æœ¬APIå·²è¢«ç¦ç”¨ï¼Œè·³è¿‡ç±»å‹æ–‡ä»¶ç”Ÿæˆ")
            );
            return;
          }
          if (genType === "declare") {
            declareContent += `\n      ${dir}: typeof import("../../invokes/${dir}/exportFn")["${dir}Fn"];`;
          } else {
            content += `  ${dir}: typeof import("../../invokes/${dir}/exportFn")["${dir}Fn"];\n`;
            declareContent += `\n      ${dir}: typeof import("../../invokes/${dir}/exportFn")["${dir}Fn"];`;
          }
        } else {
          const subDirs = readdirSync(dirPath, { withFileTypes: true })
            .filter((dirent) => dirent.isDirectory())
            .map((dirent) => dirent.name);
          if (genType === "declare") {
            declareContent += `\n      ${dir}: {`;
            //æ·»åŠ ä¸€ä¸ªå±æ€§ï¼Œç”¨äºå­˜æ”¾å½“å‰å‘½åç©ºé—´çš„é€šç”¨æ•°æ®ï¼Œæ­¤å±æ€§ä¸æä¾›ç»™ç¼–è¾‘å™¨çš„ç±»å‹å£°æ˜
            declareContent += `\n        __NS_DATA__: Record<string, any>;`;
            subDirs.forEach((subDir) => {
              const indexFilePath = resolve(
                resolve(dirPath, subDir),
                "index.ts"
              );
              const fileContent = readFileSync(indexFilePath, "utf-8");
              if (/\sdisabled:\s?(true|([1-9][0-9]*)),?/.test(fileContent)) {
                console.warn(
                  "âš ï¸ ",
                  chalk.blue(indexFilePath),
                  chalk.yellow(":æœ¬APIå·²è¢«ç¦ç”¨ï¼Œè·³è¿‡ç±»å‹æ–‡ä»¶ç”Ÿæˆ")
                );
                return;
              }
              declareContent += `\n        ${subDir}: typeof import("../../invokes/${dir}/${subDir}/exportFn")["${subDir}Fn"];`;
            });
            declareContent += "\n      };";
          } else {
            const disabledPath = [];
            content += `  ${dir}: {\n`;
            //æ·»åŠ ä¸€ä¸ªå±æ€§ï¼Œç”¨äºå­˜æ”¾å½“å‰å‘½åç©ºé—´çš„é€šç”¨æ•°æ®ï¼Œæ­¤å±æ€§ä¸æä¾›ç»™ç¼–è¾‘å™¨çš„ç±»å‹å£°æ˜
            content += `    __NS_DATA__: Record<string, any>;\n`;
            subDirs.forEach((subDir) => {
              const indexFilePath = resolve(
                resolve(dirPath, subDir),
                "index.ts"
              );
              const fileContent = readFileSync(indexFilePath, "utf-8");
              if (/\sdisabled:\s?(true|([1-9][0-9]*)),?/.test(fileContent)) {
                console.warn(
                  "âš ï¸ ",
                  chalk.blue(indexFilePath),
                  chalk.yellow(":æœ¬APIå·²è¢«ç¦ç”¨ï¼Œè·³è¿‡ç±»å‹æ–‡ä»¶ç”Ÿæˆ")
                );
                disabledPath.push(indexFilePath);
                return;
              }
              content += `    ${subDir}: typeof import("../../invokes/${dir}/${subDir}/exportFn")["${subDir}Fn"];\n`;
            });
            content += "  };\n";
            declareContent += `\n      ${dir}: {`;
            //æ·»åŠ ä¸€ä¸ªå±æ€§ï¼Œç”¨äºå­˜æ”¾å½“å‰å‘½åç©ºé—´çš„é€šç”¨æ•°æ®ï¼Œæ­¤å±æ€§ä¸æä¾›ç»™ç¼–è¾‘å™¨çš„ç±»å‹å£°æ˜
            declareContent += `\n        __NS_DATA__: Record<string, any>;`;
            subDirs.forEach((subDir) => {
              const indexFilePath = resolve(
                resolve(dirPath, subDir),
                "index.ts"
              );
              if (disabledPath.includes(indexFilePath)) {
                return;
              }
              declareContent += `\n        ${subDir}: typeof import("../../invokes/${dir}/${subDir}/exportFn")["${subDir}Fn"];`;
            });
            declareContent += "\n      };";
          }
        }
      });
      if (genType === "declare") {
        genCoreDTS(declareContent);
      } else {
        genCoreDTS(declareContent);
        genBIDTS(content, invokesPath);
      }
      console.timeEnd(chalk.green("generate use time"));
    } catch (error) {
      console.error("âŒ", "å£°æ˜æ–‡ä»¶ç”Ÿæˆå¤±è´¥:", error);
      console.timeEnd(chalk.green("generate use time"));
    }
  }, 500);
};

const syncBuildFormDeclare = (typesDir: string, invokesDir: string) => {
  console.log(
    new Date().toLocaleTimeString().slice(0, 8),
    chalk.blue("[hot-update-plugin]"),
    chalk.green("ğŸš€", "å¼€å§‹åŒæ­¥buildFormçš„ç±»å‹å£°æ˜åˆ°ç¼–è¾‘å™¨")
  );
  const buildFormContent = readFileSync(
    resolve(typesDir, "buildForm.d.ts"),
    "utf-8"
  );
  const res =
    AG_TITLE +
    `export const BUILD_FORM_DECLARE = \`\n${buildFormContent.trim()}\n\``;
  const oPath = resolve(invokesDir, "buildFormDeclare.ag.ts");
  if (existsSync(oPath)) {
    const oldContent = readFileSync(oPath, "utf-8");
    if (oldContent.trim() === res.trim()) {
      console.log(
        "âœ¨",
        "The",
        chalk.green("buildFormDeclare.ag.ts"),
        "file is not changed"
      );
      return;
    }
  }
  writeFileSync(oPath, res);
  console.log(
    "âœ¨",
    "The",
    chalk.green("buildFormDeclare.ag.ts"),
    "file is generated in the:",
    chalk.blue(oPath)
  );
};
const syncRenderListDeclare = (typesDir: string, invokesDir: string) => {
  console.log(
    new Date().toLocaleTimeString().slice(0, 8),
    chalk.blue("[hot-update-plugin]"),
    chalk.green("ğŸš€", "å¼€å§‹åŒæ­¥renderListçš„ç±»å‹å£°æ˜åˆ°ç¼–è¾‘å™¨")
  );
  const renderListContent = readFileSync(
    resolve(typesDir, "renderList.d.ts"),
    "utf-8"
  );
  const res =
    AG_TITLE +
    `export const RENDER_LIST_DECLARE = \`\n${renderListContent.trim()}\n\``;
  const oPath = resolve(invokesDir, "renderListDeclare.ag.ts");
  if (existsSync(oPath)) {
    const oldContent = readFileSync(oPath, "utf-8");
    if (oldContent.trim() === res.trim()) {
      console.log(
        "âœ¨",
        "The",
        chalk.green("renderListDeclare.ag.ts"),
        "file is not changed"
      );
      return;
    }
  }
  writeFileSync(oPath, res);
  console.log(
    "âœ¨",
    "The",
    chalk.green("renderListDeclare.ag.ts"),
    "file is generated in the:",
    chalk.blue(oPath)
  );
};

let genBFDTSTimer: NodeJS.Timeout | null = null;
export const genBuildFormDTS = (target?: "buildForm" | "renderList") => {
  genBFDTSTimer && clearTimeout(genBFDTSTimer);
  genBFDTSTimer = setTimeout(() => {
    console.time(chalk.green("sync type use time"));
    try {
      const typesDir = resolve(__dirname, "../src/types");
      const invokesDir = resolve(__dirname, "../src/invokes");
      if (target === "buildForm") {
        syncBuildFormDeclare(typesDir, invokesDir);
      } else if (target === "renderList") {
        syncRenderListDeclare(typesDir, invokesDir);
      } else {
        syncBuildFormDeclare(typesDir, invokesDir);
        syncRenderListDeclare(typesDir, invokesDir);
      }
      console.timeEnd(chalk.green("sync type use time"));
    } catch (error) {
      console.error("âŒ", error);
      console.timeEnd(chalk.green("sync type use time"));
    }
  }, 500);
};

export const genAllDTS = () => {
  genEnumDTS();
  genBuiltInApiDTS();
  genBuildFormDTS();
};
